# 思路介绍

## 问题描述
+ 给定字符串S以及模式串T，求解S每一个后缀与T的最长公共前缀的长度。假设s的长度为n，T的长度为m。
+ 也就是说，假设有数组ans，其中ans[i]表示T与S[i,n-1]的最长公共前缀的长度。
+ 显然，ans数组求解以后，ans[i]的值如果等于m，那么说明S[i,i+m-1]=T[0,m-1]。

## 思路引导
+ 思路与KMP方法类似，核心依然在于有效利用已经匹配成功字符串的信息。
+ 假设有next[i]数组，它表示T[i,m-1]与T自身匹配的最长前缀的长度。
+ 现在来具体思考求解某个具体ans[i]的过程。假设ans[0,i-1]的值已经求解，并且我们令ans[0]=0。
+ 假设在i之前的某个位置k处开始，S[k,p]=T[0,p-k]，此时i之前的每个位置与T匹配的前缀的区间右端点的值都小于等于p。
+ 此时有k < i <= p成立，根据S[k,p]=T[0,p-k]可以轻松推导出，S[i,p]=T[i-k,p-k]的结论。
+ 前面我们提到了next数组，它的含义是T[i,m-1]与T自身匹配的最长前缀的长度，而T[i-k,p-k]则是T[i,m-1]的前缀，所以我们也可以得到T与T[i-k,p-k]最大前缀的长度length。
+ 现在按照length的长度考虑不同情况：
    - 如果i+length >= p，此时从S[p+1]开始都是未匹配过得字符，这些字符与T并不一定相同，所以需要从这里开始暴力匹配，看看是否可以向右扩展p。
    - 如果i+length < p,此时S[i+length+1]!=T[length+1]，直接返回ans[i+1]的值即可。
+ 现在来讲讲next数组的求解，next数组求解实际上就是用T自身匹配自身的过程，这个过程是一个DP过程，也是按照上述步骤进行的。
